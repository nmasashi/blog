---
layout: post
title: "Claude codeでアプリを作ってみる"
date: 2025-07-22
categories: claude devapp
---

## Claude code の準備

この辺りを参考にセットアップ

https://docs.anthropic.com/ja/docs/claude-code/setup

API の従量課金制で始めることにした

→ と思ったけどやっぱり pro プランで作ることにした

開発中のコード

https://github.com/nmasashi/snaplant

## とりあえず作り始める

記念すべき最初のプロンプト

```
新しいアプリを作成しようと考えています。要件定義などのドキュメントが格納されるフォルダやソースが格納されるフォルダを作成してください
```

フォルダができた。

```sh
.
├── docs
└── src
```

## 要件定義をしてもらう

```
作成したいのは植物図鑑を自分で作成するようなアプリです。
撮影した写真をアップロードすることでその写真に写っている植物を特定します。
そして、あとから図鑑形式で見ることができるアプリです。
まずは要件定義から行います。要件定義のひな形としてdocs/01_requirements.mdを作成してください
```

<details close markdown="1">
  <summary>作成された01_requirements.md</summary>

```
# SnapPlant - 植物図鑑アプリ要件定義書

## 1. プロジェクト概要

### 1.1 プロダクト名

SnapPlant（スナップ植物）

### 1.2 目的

撮影した植物の写真を自動識別し、個人の植物図鑑を作成・管理できる Web アプリケーション

### 1.3 対象ユーザー

- 植物愛好家
- ガーデニング初心者
- 散歩やハイキング中に植物に興味を持つ人
- 学習目的で植物を覚えたい人

## 2. 機能要件

### 2.1 コア機能

#### 2.1.1 写真アップロード機能

- **説明**: ユーザーが撮影した植物の写真をアップロードできる
- **要件**:
  - JPEG, PNG 形式の画像をサポート
  - 最大ファイルサイズ: 10MB
  - ドラッグ&ドロップ対応
  - カメラからの直接撮影（モバイル対応）
  - プレビュー機能

#### 2.1.2 植物識別機能

- **説明**: アップロードされた写真から植物を自動識別する
- **要件**:
  - AI/機械学習ベースの植物識別
  - 識別結果の信頼度表示
  - 複数の候補表示（上位 3-5 候補）
  - 手動での識別結果修正機能

#### 2.1.3 図鑑管理機能

- **説明**: 識別した植物を個人の図鑑として保存・管理できる
- **要件**:
  - 植物データの保存（名前、写真、識別日時、場所）
  - 図鑑一覧表示（グリッド/リスト表示）
  - 植物詳細情報の表示
  - お気に入り機能
  - 検索・フィルタリング機能

### 2.2 付加機能

#### 2.2.1 植物情報表示

- 植物の基本情報（学名、科名、特徴）
- 季節情報（開花時期、果実時期等）
- 分布情報

#### 2.2.2 記録機能

- 撮影場所の記録（GPS 情報）
- 撮影日時の記録
- メモ機能（個人的な観察記録）

#### 2.2.3 データエクスポート機能

- CSV 形式でのデータ出力
- 画像付き PDF レポート生成

## 3. 非機能要件

### 3.1 パフォーマンス

- 写真アップロード後、5 秒以内に識別結果を表示
- 図鑑一覧の表示は 2 秒以内
- 同時接続ユーザー数: 100 人

### 3.2 ユーザビリティ

- レスポンシブデザイン（PC、タブレット、スマートフォン対応）
- 直感的で分かりやすい UI
- アクセシビリティ対応（WCAG 2.1 AA 準拠）

### 3.3 セキュリティ

- ユーザーデータの暗号化
- 画像ファイルのウイルススキャン
- API レート制限

### 3.4 データ保持

- ユーザーデータの永続化
- 定期的なバックアップ
- データ削除機能

## 4. 技術要件

### 4.1 フロントエンド

- **フレームワーク**: React + TypeScript
- **ビルドツール**: Vite
- **UI ライブラリ**: Material-UI または Chakra UI
- **状態管理**: Context API または Redux Toolkit

### 4.2 バックエンド

- **API**: RESTful API
- **認証**: JWT または OAuth
- **ファイルストレージ**: AWS S3 または Google Cloud Storage

### 4.3 植物識別 API

- **候補 1**: PlantNet API
- **候補 2**: Google Vision AI Plant API
- **候補 3**: カスタム機械学習モデル

### 4.4 データベース

- **種類**: PostgreSQL または MongoDB
- **ORM**: Prisma または TypeORM

## 5. ユーザーストーリー

### 5.1 基本フロー

1. **写真撮影・アップロード**

   - ユーザーが植物の写真を撮影またはアップロード
   - システムが画像を受信・処理

2. **植物識別**

   - AI が植物を識別
   - 識別結果と信頼度を表示
   - ユーザーが結果を確認・修正

3. **図鑑への追加**

   - 識別結果を個人の図鑑に保存
   - 場所・日時・メモを追加

4. **図鑑閲覧**
   - 保存した植物を図鑑形式で閲覧
   - 検索・フィルタリングで目的の植物を探索

## 6. 画面構成

### 6.1 主要画面

- **ホーム画面**: 写真アップロード、最近の識別結果
- **識別結果画面**: AI 識別結果の表示・確認
- **図鑑一覧画面**: 保存した植物の一覧表示
- **植物詳細画面**: 個別植物の詳細情報
- **設定画面**: アプリ設定、データ管理

## 7. 開発フェーズ

### フェーズ 1: MVP (最小実行可能プロダクト)

- 写真アップロード機能
- 基本的な植物識別機能
- シンプルな図鑑表示

### フェーズ 2: 機能拡張

- 検索・フィルタリング機能
- 詳細な植物情報表示
- GPS・メモ機能

### フェーズ 3: 高度機能

- データエクスポート
- ユーザー認証
- クラウド同期

## 8. 成功指標

- 月間アクティブユーザー数
- 識別精度（85%以上）
- ユーザー満足度スコア（4.0 以上/5.0）
- 図鑑登録数（ユーザー 1 人あたり平均 50 種以上）
```

</details>

なんかもりもりな要件定義書ができた。
技術要件はまた別で考えたいためここでは削除してもらう。
画面構成と開発フェーズと成功指標も削除。例えばこんな感じ。

```
 ## 4. 技術要件
 ## 6. 画面構成
 ## 7. 開発フェーズ
 ## 8. 成功指標
 は削除してください。またあとで考えます。
```

他にもなんかいろいろ削除してスッキリさせた

<details close markdown="1">
  <summary>修正した 01_requirements.md</summary>

```
# SnapPlant - 植物図鑑アプリ要件定義書

## 1. プロジェクト概要

### 1.1 プロダクト名

SnapPlant（スナップ植物）

### 1.2 目的

撮影した植物の写真を自動識別し、個人の植物図鑑を作成・管理できるAndroidアプリケーション

### 1.3 対象ユーザー

- 植物愛好家
- ガーデニング初心者
- 散歩やハイキング中に植物に興味を持つ人
- 学習目的で植物を覚えたい人

## 2. 機能要件

### 2.1 コア機能

#### 2.1.1 写真アップロード機能

- **説明**: ユーザーが撮影した植物の写真をアップロードできる
- **要件**:
  - JPEG, PNG 形式の画像をサポート
  - カメラからの直接撮影
  - ギャラリーからの画像選択
  - プレビュー機能

#### 2.1.2 植物識別機能

- **説明**: アップロードされた写真から植物を自動識別する
- **要件**:
  - AI/機械学習ベースの植物識別
  - 識別結果の信頼度表示
  - 複数の候補表示（上位 3 候補）

#### 2.1.3 図鑑管理機能

- **説明**: 識別した植物を個人の図鑑として保存・管理できる
- **要件**:
  - 植物データの保存（名前、写真、識別日時）
  - 図鑑一覧表示（リスト表示）
  - 植物詳細情報の表示


## 3. 非機能要件

### 3.1 ユーザビリティ

- Android端末対応（Android 8.0以上）
- 直感的で分かりやすいUI
- オフライン環境での基本動作（図鑑閲覧）

## 4. ユーザーストーリー

### 4.1 基本フロー

1. **写真撮影**
   - ユーザーがカメラで植物を撮影
   - またはギャラリーから画像を選択

2. **植物識別**
   - AIが植物を識別
   - 識別結果と信頼度を表示
   - 上位3候補を表示

3. **図鑑への保存**
   - 識別結果を個人の図鑑に保存
   - 撮影日時を自動記録

4. **図鑑閲覧**
   - 保存した植物を一覧で表示
   - タップして詳細情報を表示

```

</details>

## 機能一覧を作成してもらう

こんな感じで投げてみる

```
あなたはモバイルアプリの設計に詳しいエンジニアです。
  01_requirements.md
  に基づいてユーザー視点で整理された機能一覧表をMarkdownで作成してください。
  出力形式は以下のようなMarkdown表でお願いします：
  | ID | 機能名 | 概要 |
  |----|--------|------|
```

ちょっとモリモリだったからいろいろけしてこうなった。

<details close markdown="1">
  <summary>作成された 02_feature_list.md</summary>

```
  # SnapPlant 機能一覧表

## ユーザー視点での機能一覧

| ID   | 機能名         | 概要                                           |
| ---- | -------------- | ---------------------------------------------- |
| F001 | ギャラリー選択 | 端末のギャラリーから既存の植物写真を選択できる |
| F002 | 写真プレビュー | 選択した写真を確認してから識別処理に進める     |
| F003 | AI 植物識別    | 機械学習により写真の植物を自動識別する         |
| F004 | 識別結果表示   | 植物名と識別の信頼度を分かりやすく表示する     |
| F005 | 候補一覧表示   | 識別結果の上位 3 候補を確認できる              |
| F006 | 図鑑保存       | 識別した植物を個人の図鑑に保存する             |
| F007 | 図鑑一覧表示   | 保存した植物をリスト形式で一覧表示する         |
| F008 | 植物詳細表示   | 個別の植物をタップして詳細情報を表示する       |

## 画面フロー順の機能グループ

### 写真取得グループ

- F001: ギャラリー選択
- F002: 写真プレビュー

### 識別グループ

- F003: AI 植物識別
- F004: 識別結果表示
- F005: 候補一覧表示

### 図鑑管理グループ

- F006: 図鑑保存
- F007: 図鑑一覧表示
- F008: 植物詳細表示

## 優先度別分類

### 高優先度（MVP 必須）

- F001: ギャラリー選択
- F003: AI 植物識別
- F004: 識別結果表示
- F006: 図鑑保存
- F007: 図鑑一覧表示
- F008: 植物詳細表示

### 中優先度（MVP 後期追加）

- F002: 写真プレビュー
- F005: 候補一覧表示

```

</details>

## 画面遷移図とワイヤーフレーム作ってもらう

最初はこんな感じでお願いしてみた。

```
 Mermaidを使用して画面遷移図を作成してください。
  下記の四つの画面は最低限含めて下さい。また、植物一覧画面が初期画面になるようにしてください
  - 植物一覧画面
  - 画像アップロード画面
  - 植物詳細
  - 画像判定画面
```

ワイヤーフレームは Mermaid だといまいちイメージわかなかったので、ASCII Art で妥協

こんな感じで画面のワイヤーフレームは作ってくれる

```
┌─────────────────────────────────────────┐
│   SnapPlant                       [+] │ ← ヘッダー (60px) + 追加ボタン
├─────────────────────────────────────────┤
│ ┌───────┐                              │
│ │       │  桜                          │
│ │ 画像  │  春に美しいピンクの花を咲かせる  │ ← リストアイテム1
│ │       │                              │
│ └───────┘                              │
├─────────────────────────────────────────┤
│ ┌───────┐                              │
│ │       │  梅                          │
│ │ 画像  │  冬〜早春に芳香のある花を咲かせる │ ← リストアイテム2
│ │       │                              │
│ └───────┘                              │
├─────────────────────────────────────────┤
│ ┌───────┐                              │
│ │       │  菜の花                       │
│ │ 画像  │  春に黄色い花を咲かせ、畑や川土手 │ ← リストアイテム3
│ │       │  に見られる                     │
│ └───────┘                              │
├─────────────────────────────────────────┤
│              (以下同様...)               │
└─────────────────────────────────────────┘
```

まぁ、いっか（笑）

そして、他にもデータベース設計や技術選定、api デザインなんかもろもろやってもらった。
ざっとみ中身は問題なさそうなので、そのまま進める。みすってたら見直す感じでとりあえず進む（笑）

## インフラ構築

terraform を利用してインフラ構築用のコードを書いてもらった。この辺りはできるだけコストを抑えるようなプロンプトを書いてコードを書いてもらった。
今回は functions と cosmosDB と open ai サービスの組合せのアプリだったため、インフラコードもそこまで複雑ではなく特に問題なかった。

## API 開発

API 設計書は作成してたため、それに沿ってソースとテスト書いて～ってお願いして就寝（笑）

次の日にテストを実施。当然のように通らないが自動でソース修正が入って、再テストの繰り返し。3 回くらい繰り返すと全部のテストが通るようになっていた。

ソースコードに変な部分がないか確認していく

早速おかしい(笑)

```TypeScript
export async function identifyPlantHandler(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
  context.log('植物識別リクエストを受信');

  try {
    // Function Key認証チェック
    if (!validateFunctionKey(request)) {
      context.log('認証エラー: Function Keyが無効');
      return createUnauthorizedError();
    }
  ...
```

Function Key 認証チェックをしているが Function Key 認証チェックは各 function で実施されるものではなく、function 実行前に azure 側で検証されるもの。このコードは不要。

ということで指摘してみる。

```
functionsに含まれるソースコードで「Function Key認証チェック」を実施しています
Function Keyに誤りがあった場合でもfunctionsの関数は実行されるということでしょうか？実行前にazure側ではじかれると思っていました
```

返答

```
● 素晴らしい質問です！実際、現在の実装には設計上の問題があります。

  現在の実装の問題点

  ...

Azure FunctionsのauthLevel: 'function'設定で十分なので、アプリケーション側の認証チェックを削除することを推奨します。
```

ということで削除してもらった。

- 他にも定数などのべた書きがあったので定数ファイルを作成してもらうように修正
- 外部 URL の画像(blob 外の画像)も扱うようになっていたので修正
- custom vision を使用していたが、それだとタグ（flower とか tree）とかまでしかわからないので、LLM で画像分析してもらうように変更
- 修正によって変更した影響をドキュメントに反映 & terraform でインフラ環境再整備

ちなみに実装はこんな感じで functions フォルダが mvc モデルいうところの c に相当している
service フォルダが m に相当（api なので v はない）

```
├── constants
│   └── validation.ts
├── functions
│   ├── identify.ts
│   ├── plantDetail.ts
│   ├── plants.ts
│   ├── save.ts
│   └── upload.ts
├── services
│   ├── cosmosService.ts
│   ├── openAIVisionService.ts
│   └── storageService.ts
├── types
│   ├── api.ts
│   └── plant.ts
└── utils
    └── response.ts
```

テストを見てみる。
functions のテストをしようとしているファイル

```ts
// OpenAIVisionServiceのモック
jest.mock('../../src/services/openAIVisionService');
const MockedOpenAIVisionService = OpenAIVisionService as jest.MockedClass<typeof OpenAIVisionService>;

describe('植物識別API', () => {
  let mockContext: InvocationContext;
  let mockOpenAIVisionService: jest.Mocked<OpenAIVisionService>;
  ...
```

ん～。service のモック作っちゃうのか。ロンドン学派なのかな？この手法だと「単体テストの考え方/使い方」でいうところのリファクタリングへの耐性が低くなってしまう。

プロンプトできいてみる

```
「単体テストの考え方/使い方 — プロジェクトの持続可能な成長を実現するための戦略」という書籍を知っていますか？
```

返答

```
● はい、知っています。「単体テストの考え方/使い方 — プロジェクトの持続可能な成長を実現するための戦略」は Vladimir Khorikov による優れた書籍です。

  書籍の主要なポイント：

  1. 良い単体テストの4つの柱
  ...

  現在のテストに関して：

  選択されたコードを見ると、Function層テストでOpenAIVisionServiceをモックしています。これは書籍の考え方に適合しています：

  - ✅ OpenAI API = 管理されていない外部依存関係 → モック適切
  - ✅ HTTP層での統合テスト的アプローチ
  - ✅ ビジネスロジックの動作をテスト

  改善の余地があるとすれば：
  - サービス層の単体テストでAzure SDKをモックするのは適切
  - しかし、同一プロジェクト内のサービス間でのモック使用は慎重に検討

  書籍の考え方を適用すると、現在のテスト戦略は概ね良い方向性です。
```

**選択されたコードを見ると、Function 層テストで OpenAIVisionService をモックしています。これは書籍の考え方に適合しています**

↑ ほんとにそうか？？？

文句を言う

```
Function層でservice層のモックを作成していますが、サービスそうは外部依存ではないため、モックを立てることはこの書籍の考え方とは外れていると思います。
CosmosDBは外部依存なので、モックの使用は良いと思います。
```

返答

```
おっしゃる通りです。非常に的確な指摘です。

  書籍の考え方に基づく正しい分析：

  ❌ 現在の問題点：
  - Function層でOpenAIVisionService（同一プロジェクト内）をモック → 不適切
  - サービス層は「管理されている依存関係」なのでモックすべきでない

  ✅ 適切なアプローチ：
  - Function層では実際のOpenAIVisionServiceインスタンスを使用
  - OpenAIVisionService内でOpenAI API（外部依存）のみモック
  - CosmosService内でCosmos DB SDK（外部依存）のみモック

  正しいテスト構造：

  // Function層テスト（統合テスト的）
  describe('植物識別API', () => {
    // OpenAIVisionServiceは実際のインスタンスを使用
    // ただし、OpenAI APIコール部分はモック
  });

  // Service層テスト（単体テスト）
  describe('OpenAIVisionService', () => {
    // OpenAI SDKのみモック（外部依存）
  });

  現在の実装の問題：
  Function層でサービス層をモックすることで、実際のサービス層との統合部分がテストされていない状況になっています。

  この指摘により、テスト戦略を書籍の考え方に沿って見直す必要がありますね。Function層のテストを修正し、サービス層は実際のインスタンスを使いつつ、外部依存のみモックする形に変更すべきです。
```

こいつ適当に言ってないか？（やりたいことはそうなんだけど）

つめる(笑)

```
なぜ変更すべきなのか具体的に説明してください。下記の単体テストの4本柱の観点で説明をしてください
  - 退行(regression)に対する保護
  - リファクタリングへの耐性
  - 迅速なフィードバック
  - 保守のしやすさ
```

返答

```
● 優れた質問です。4つの柱の観点から現在のテスト戦略の問題点を具体的に説明します。

  1. 退行に対する保護 ❌

  現在の問題：
  - Function層でサービス層をモックすることで、サービス層の実装変更が検出されない
  - 例：OpenAIVisionServiceのidentifyPlantメソッドのロジックにバグが混入しても、Function層テストでは検出できない
  ...

  2. リファクタリング耐性 ❌

  現在の問題：
  - サービス層のメソッド名やシグネチャ変更時に、Function層テストが実装の詳細に依存している
  - モックの設定が実装と密結合になっている
  ...

  3. 迅速なフィードバック △（変化なし）

  現在の状況：
  - モック使用により実行速度は高速
  - しかし、間違ったフィードバックを高速で得ている状態
  - 本来検出すべき問題を見逃している

  4. 保守のしやすさ ❌

  現在の問題：
  - 二重のモック管理：Function層とService層の両方でモック設定が必要
  - サービス層の変更時に複数のテストファイルを更新する必要

  ...

  正しいアプローチとその利点

  Function層テスト（統合テスト的）：
  describe('植物識別API', () => {
    beforeEach(() => {
      // 外部依存のみモック
      jest.mock('openai');
      // サービス層は実際のインスタンスを使用
    });
  });

  利点：
  1. 退行保護: サービス層の実装バグも検出
  2. リファクタリング耐性: サービス層の内部変更に影響されない
  3. 迅速なフィードバック: 正確な問題検出
  4. 保守性: モック管理が単純化、変更箇所が明確

  現在のアプローチは「テストのためのテスト」になっており、実際の品質保証という目的から外れています。
```

せやな。

ということで、外部依存のみモックを利用するようにテストを修正してもらった。

他にも、ソースを読むと必要な機能が未実装だったり、明らかに効率が悪い方法で実装していたりしていた。

- 重複チェックで DB に同じ植物名を select するようなクエリを投げれば済む場面で、全権取得してチェックしようとしていた。

他にもいろいろ文句は言ったが、自動で DB のモックなどを作成してテストを作ってくれるのはありがたい。

## フロントエンド開発

モバイルアプリのフロントエンドは全然わからんのでお任せ(笑)

とりあえず flutter でやってねだけお願いして。環境構築してもらってコード生成してもらった。
エラーでたらひたすら文句言いまくる単純作業ゲー

**植物一覧画面**

![]({{site.baseurl}}/images/claude/devapp/screen1.png)

**画像アップロード画面**

- 画像選択前

![]({{site.baseurl}}/images/claude/devapp/screen2.png)

- 画像選択後

![]({{site.baseurl}}/images/claude/devapp/screen3.png)

**画像識別画面**

![]({{site.baseurl}}/images/claude/devapp/screen4-1.png)
![]({{site.baseurl}}/images/claude/devapp/screen4-2.png)

**保存後の一覧**

![]({{site.baseurl}}/images/claude/devapp/screen5.png)

**植物詳細画面**

![]({{site.baseurl}}/images/claude/devapp/screen6-1.png)
![]({{site.baseurl}}/images/claude/devapp/screen6-2.png)

まだ改良したい部分は多いけどたたき台には十分になるものができた！！

## 感想

API 開発では生成されたコードの評価ができた気がするが、フロント部分はあまり知識がないのとめんどくさくてほとんどしなかった。

ただ、API 開発で function の認証部分であったり、単体テストの作成方法がいまいち良くなかったり気になる部分はあった。そこを判断できる知識は持っておいた方がいいのだろうと思った。それにおそらくまだ変な書き方をしている部分は結構あると思う。。。

しかし、変な書き方をしてもセキュリティ的に問題なければ運用も AI 任せになるとすれば、別にいいのかなとも思うし難しい。。。なにを勉強したらいいのかよくわからんな～

ただ、このアプリは今後も自分好みに改造していく予定！！
