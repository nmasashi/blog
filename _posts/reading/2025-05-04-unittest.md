---
layout: post
title: "単体テストの考え方/使い方"
date: 2025-06-04
categories: reading unittesting
---

![]({{site.baseurl}}/images/reading/unit_testing/bookcover.jpg)

これ読んだまとめとか感想とか

## 第 1 章 なぜ、単体テストを行うのか

- 単体テストをすることでソフトウェア開発プロジェクトを持続可能にするため

  → 持続可能とはソースの変更が会った際に、退行した機能がないか検出できているかが大きい

テストの品質が悪い場合はテストなしと同じようにプロジェクトは停滞する可能性がある。
単体テストがどのように、このプロジェクトを助けるのかの理解をしていないと品質が低いテストになるリスクが大きくなる。

テストスイート：目的や対象ごとにテスト・ケースを集めたもの

テストの網羅率(coverage)はテスト・スイートの質の良さを示すことができるものではない（悪さを示すことはできる）。

コード網羅率ではテストで実行された行数の割合が算出される。しかし、三項演算子などで一行で二つの条件分岐があるようなコードは想定している網羅率にならないことがある。
この場合は、分岐網羅率を図ることで対応することはできる。

**網羅率が高くてもテストスイートの質がいいとは言えない理由**

- ただその行を通っただけで何かを確かめた（テスト）したとは限らない
- ライブラリを使用した場合、ライブラリ内のコードは網羅率の計算には入らない

網羅率は目標にするのではなく、テストが十分に実施されていない指標にするべき

**テストスイートの品質をあげるには、結局のところテストケースをひとつづつ評価していくしかない。**

テストの実施は開発サイクルの中に含まれる必要がある

システムの重要なビジネスロジックに対するテストに時間を費やすべき。それ以外の部分は簡易なものか間接的なものでも OK

**単体テストで最小限の保守コストで最大限の効果を生み出すには**

- 価値あるテストケースを認識できること
- 価値あるテストケースを作成できること

**感想**

網羅率を目標にする意味があまりないことの意味がわかった。
ただ、「網羅率 100%いってないじゃん！！それだめじゃね？」と言われたらなんて言い返せばいいのかまだよくわからない。目標として 100%を目指すのは間違えだけどよいテストスイートができてると、おのずと 100%になる？

## 第 2 章 単体テストとは何か？

**単体テストの性質**

- 自動化されている
- 「単体 (unit)」と呼ばれる少量のコードを検証する
- 実行時間が短い
- 隔離された状態で実行される

**ロンドン学派（モック主義者）**

- テスト対象に依存するクラスはテスト・ダブルに置き換える
- 一度に 1 つのクラスしか検査しない
- テスト失敗時に原因クラスがすぐわかる
- クラス間の依存が多く複雑な場合に有効
- テストに必要な準備を減らせる
- テストケースがシンプルになる

**古典学派（デトロイト派）**

- DB などのシステム外の依存（ = 共有依存）はテスト・ダブルに置き換える
- 共有依存以外はテスト・ダブルは使用しない
- 複数のテストを同時・順番を入れかえてもよい
- 確認できる範囲が広い

テスト・ダブル：モックと同じような意味で使用されているが厳密には違う。モックはテスト・ダブルの一種

依存の種類

- 依存
  - 共有依存：DB とかファイルとか
  - プライベート依存
    - 可変依存：他クラスなど
    - 不変依存：値オブジェクト（定数など）

ロンドン学派と古典学派の特徴

|                            | ロンドン学派       | 古典学派       |
| -------------------------- | ------------------ | -------------- |
| 隔離対象                   | 単体               | テスト・ケース |
| 単体の意味                 | 1 つのクラス       | 1 つの機能     |
| テスト・ダブル置き換え対象 | 共有依存、可変依存 | 共有依存       |

**細かな粒度による検証**

- ロンドン学派：テスト単位では細かすぎて、なんの検証か不明になることがある。特に非開発者には何のテストか不明になりがち
- 古典学派：テスト対象のが広いため、どのようなストーリーなのかがわかりやすい

**複雑な依存関係を持つ者に対する単体テスト**

- ロンドン学派：テスト対象外をモックにするため、依存関係が複雑なシステムの単体テストも容易に書くことができる
- 古典学派：テストのために関係するクラスの準備が必要なため、依存関係が複雑だと準備が大変

ただ、古典学派の主張は複雑な依存関係を持つシステムの場合、設計に問題がある場合がある可能性がある。

**テストが失敗したとき**

- ロンドン学派：テストが失敗した場合、テスト対象以外がモック化されているため、修正が必要な箇所が直ぐにわかる
- 古典学派：共有依存以外モック化していないためどこが修正が必要なのか直ぐにはわからない

ただ、古典学派の問題点はそもそも問題なのか？単体テストの理想はコードが変更される度に実施されるべきで、そうしていれば最後に変更したコードに原因があるのは直ぐにわかる。
また、複数のテストーケースが NG になる場合があるが、それは影響範囲の大きさを知ることができる有益な情報になる。

**古典学派の考え方を踏まえた単体テストの考えかた**

- 1 単位の振る舞いを検証すること
- 実行時間が短いこと
- 他のテストケースから隔離された状態で実行されること

**感想**

振る舞いの定義が重要だと感じた。t_wada 曰く、「この本では対象の実行前後の差異とそれによって目的が達成されたかという意味では？」とのこと

## 第 3 章 単体テストの構造的解析

**単体テストのフェーズ（AAA パターン）**

- 準備(Arrange)：テストケースの事前条件を満たし、依存状態を設定する。
- 実行(Act)：テスト対象のメソッドの呼び出し。
- 確認(Assert)：実行結果が想定通りが確認する。実行の際の戻り値や依存関係にあるオブジェクトの状態変化が想定通りかなどの確認を行う。

例

```java
public class CalculatorTests
{
  [Fact]
  public void Sum_of_two_numbers()
  {
    // 準備 (Arrange)
    double first = 10;
    double second = 20;
    var calculator = new Calculator();

    // 実行 (Act)
    double result = calculator.Sum(first, second);

    // 確認 (Assert)
    Assert.Equal(30, result);
  }
}

```

**アンチパターン**

- 準備 → 実行 A→ 確認 A→ 実行 B→ 確認 B のように複数の実行と確認を行うこと

  → 分割した単体テストとするべき

- if 文の使用

  → テストないにロジックが入ると理解しずらい

**各フェーズのコード量**

- 準備フェーズのコードが一番大きくなる
  - 他テストケースでも共通的に使用する準備フェーズのコードがあるならプライベート関数などで共有するとよい
- 実行フェーズのコードは 1 行が基本
  - カプセル化などの設計が正しくできているのかなどの観点で設計を見直す
- 確認フェーズが大きくなりすぎることには注意を払っておく

**各テストケースはプロダクションコードが解決しようとしている物語について語るべき**

もしテストが失敗した場合は、コード修正か物語（設計？）の修正を行う必要がある

単体テストの理想形は非開発者でも内容が伝わること。

**テスト・フィクスチャの作成**

テスト・フィクスチャ：テストを実施する際に使用するオブジェクト。データベースのデータやディス上のファイル等。テストケースが実行される前に決められた状態に毎回しておくために準備するもの

アンチパターン

- コンストラクタで固定値のようなものを設定する。
  - 固定値の変更が複数テストに影響を与える
  - テストが読みにくくなる
  - 例外として、すべてのテストパターンで同じテスト・フィクスチャを利用する場合はコンストラクタでも OK

いい方法

- 固定値ではなくプライベートの関数を作成して、テスト用のオブジェクトを返すようなものを作成する

**テストメソッドの命名**

- 厳格な命名規則のせいで何をしたいテストかわからなくなる場合があるので、ある程度の自由さが必要
- 非開発者に伝わるように心掛ける
- アンダースコアで区切るのは基本

テストしたいメソッドではなくストーリをテストメソッドにする方法もあり

```java
// 例：配送サービスで過去日付が指定できないことをテストしたいテストメソッド

// よくない例：関数名をテストメソッドに入れた版
// IsDeliveryValid_不正な日付はFalseを返す
public void IsDelivery_Valid_invalidDate_ReturnsFalse()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

// いい例：振る舞いを書いた版
// 不正な日付が指定された配達は不正だとみなされるべきである
public void Delivery_with_invalid_data_should_be_considered_invalid()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

// さらに改良
// 過去の日付が指定された配達は不正である
public void Delivery_with_a_past_date_is_invalid()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

```

- テストしたいのはメソッドではなくアプリの振る舞いなので、メソッド名を付けるのはおかしい。
- さらにテスト対象のメソッド名が変わるとテストのメンテナンスも必要になる。
- ただし、例外としてユーティリティ系のテストコードはこの規則から外すべき。

**テストクラスの命名**

- {クラス名}Tests が基本
- {クラス名}のクラスが呼び出しの起点になるだけで、このクラスだけのテストをしているわけではない（古典学派のテストの場合）。

## 第 4 章 良い単体テストを構成する 4 本の柱
