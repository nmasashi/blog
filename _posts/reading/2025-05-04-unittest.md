---
layout: post
title: "単体テストの考え方/使い方"
date: 2025-06-04
categories: reading unittesting
---

![]({{site.baseurl}}/images/reading/unit_testing/bookcover.jpg)

これ読んだまとめとか感想とか

## 第 1 章 なぜ、単体テストを行うのか

- 単体テストをすることでソフトウェア開発プロジェクトを持続可能にするため

  → 持続可能とはソースの変更が会った際に、退行した機能がないか検出できているかが大きい

テストの品質が悪い場合はテストなしと同じようにプロジェクトは停滞する可能性がある。
単体テストがどのように、このプロジェクトを助けるのかの理解をしていないと品質が低いテストになるリスクが大きくなる。

テストスイート：目的や対象ごとにテスト・ケースを集めたもの

テストの網羅率(coverage)はテスト・スイートの質の良さを示すことができるものではない（悪さを示すことはできる）。

コード網羅率ではテストで実行された行数の割合が算出される。しかし、三項演算子などで一行で二つの条件分岐があるようなコードは想定している網羅率にならないことがある。
この場合は、分岐網羅率を図ることで対応することはできる。

**網羅率が高くてもテストスイートの質がいいとは言えない理由**

- ただその行を通っただけで何かを確かめた（テスト）したとは限らない
- ライブラリを使用した場合、ライブラリ内のコードは網羅率の計算には入らない

網羅率は目標にするのではなく、テストが十分に実施されていない指標にするべき

**テストスイートの品質をあげるには、結局のところテストケースをひとつづつ評価していくしかない。**

テストの実施は開発サイクルの中に含まれる必要がある

システムの重要なビジネスロジックに対するテストに時間を費やすべき。それ以外の部分は簡易なものか間接的なものでも OK

**単体テストで最小限の保守コストで最大限の効果を生み出すには**

- 価値あるテストケースを認識できること
- 価値あるテストケースを作成できること

**感想**

網羅率を目標にする意味があまりないことの意味がわかった。
ただ、「網羅率 100%いってないじゃん！！それだめじゃね？」と言われたらなんて言い返せばいいのかまだよくわからない。目標として 100%を目指すのは間違えだけどよいテストスイートができてると、おのずと 100%になる？

## 第 2 章 単体テストとは何か？

**単体テストの性質**

- 自動化されている
- 「単体 (unit)」と呼ばれる少量のコードを検証する
- 実行時間が短い
- 隔離された状態で実行される

**ロンドン学派（モック主義者）**

- テスト対象に依存するクラスはテスト・ダブルに置き換える
- 一度に 1 つのクラスしか検査しない
- テスト失敗時に原因クラスがすぐわかる
- クラス間の依存が多く複雑な場合に有効
- テストに必要な準備を減らせる
- テストケースがシンプルになる

**古典学派（デトロイト派）**

- DB などのシステム外の依存（ = 共有依存）はテスト・ダブルに置き換える
- 共有依存以外はテスト・ダブルは使用しない
- 複数のテストを同時・順番を入れかえてもよい
- 確認できる範囲が広い

テスト・ダブル：モックと同じような意味で使用されているが厳密には違う。モックはテスト・ダブルの一種

依存の種類

- 依存
  - 共有依存：DB とかファイルとか
  - プライベート依存
    - 可変依存：他クラスなど
    - 不変依存：値オブジェクト（定数など）

ロンドン学派と古典学派の特徴

|                            | ロンドン学派       | 古典学派       |
| -------------------------- | ------------------ | -------------- |
| 隔離対象                   | 単体               | テスト・ケース |
| 単体の意味                 | 1 つのクラス       | 1 つの機能     |
| テスト・ダブル置き換え対象 | 共有依存、可変依存 | 共有依存       |

**細かな粒度による検証**

- ロンドン学派：テスト単位では細かすぎて、なんの検証か不明になることがある。特に非開発者には何のテストか不明になりがち
- 古典学派：テスト対象のが広いため、どのようなストーリーなのかがわかりやすい

**複雑な依存関係を持つ者に対する単体テスト**

- ロンドン学派：テスト対象外をモックにするため、依存関係が複雑なシステムの単体テストも容易に書くことができる
- 古典学派：テストのために関係するクラスの準備が必要なため、依存関係が複雑だと準備が大変

ただ、古典学派の主張は複雑な依存関係を持つシステムの場合、設計に問題がある場合がある可能性がある。

**テストが失敗したとき**

- ロンドン学派：テストが失敗した場合、テスト対象以外がモック化されているため、修正が必要な箇所が直ぐにわかる
- 古典学派：共有依存以外モック化していないためどこが修正が必要なのか直ぐにはわからない

ただ、古典学派の問題点はそもそも問題なのか？単体テストの理想はコードが変更される度に実施されるべきで、そうしていれば最後に変更したコードに原因があるのは直ぐにわかる。
また、複数のテストーケースが NG になる場合があるが、それは影響範囲の大きさを知ることができる有益な情報になる。

**古典学派の考え方を踏まえた単体テストの考えかた**

- 1 単位の振る舞いを検証すること
- 実行時間が短いこと
- 他のテストケースから隔離された状態で実行されること

**感想**

振る舞いの定義が重要だと感じた。t_wada 曰く、「この本では対象の実行前後の差異とそれによって目的が達成されたかという意味では？」とのこと

## 第 3 章 単体テストの構造的解析

**単体テストのフェーズ（AAA パターン）**

- 準備(Arrange)：テストケースの事前条件を満たし、依存状態を設定する。
- 実行(Act)：テスト対象のメソッドの呼び出し。
- 確認(Assert)：実行結果が想定通りが確認する。実行の際の戻り値や依存関係にあるオブジェクトの状態変化が想定通りかなどの確認を行う。

例

```java
public class CalculatorTests
{
  [Fact]
  public void Sum_of_two_numbers()
  {
    // 準備 (Arrange)
    double first = 10;
    double second = 20;
    var calculator = new Calculator();

    // 実行 (Act)
    double result = calculator.Sum(first, second);

    // 確認 (Assert)
    Assert.Equal(30, result);
  }
}

```

**アンチパターン**

- 準備 → 実行 A→ 確認 A→ 実行 B→ 確認 B のように複数の実行と確認を行うこと

  → 分割した単体テストとするべき

- if 文の使用

  → テストないにロジックが入ると理解しずらい

**各フェーズのコード量**

- 準備フェーズのコードが一番大きくなる
  - 他テストケースでも共通的に使用する準備フェーズのコードがあるならプライベート関数などで共有するとよい
- 実行フェーズのコードは 1 行が基本
  - カプセル化などの設計が正しくできているのかなどの観点で設計を見直す
- 確認フェーズが大きくなりすぎることには注意を払っておく

**各テストケースはプロダクションコードが解決しようとしている物語について語るべき**

もしテストが失敗した場合は、コード修正か物語（設計？）の修正を行う必要がある

単体テストの理想形は非開発者でも内容が伝わること。

**テスト・フィクスチャの作成**

テスト・フィクスチャ：テストを実施する際に使用するオブジェクト。データベースのデータやディス上のファイル等。テストケースが実行される前に決められた状態に毎回しておくために準備するもの

アンチパターン

- コンストラクタで固定値のようなものを設定する。
  - 固定値の変更が複数テストに影響を与える
  - テストが読みにくくなる
  - 例外として、すべてのテストパターンで同じテスト・フィクスチャを利用する場合はコンストラクタでも OK

いい方法

- 固定値ではなくプライベートの関数を作成して、テスト用のオブジェクトを返すようなものを作成する

**テストメソッドの命名**

- 厳格な命名規則のせいで何をしたいテストかわからなくなる場合があるので、ある程度の自由さが必要
- 非開発者に伝わるように心掛ける
- アンダースコアで区切るのは基本

テストしたいメソッドではなくストーリをテストメソッドにする方法もあり

```java
// 例：配送サービスで過去日付が指定できないことをテストしたいテストメソッド

// よくない例：関数名をテストメソッドに入れた版
// IsDeliveryValid_不正な日付はFalseを返す
public void IsDelivery_Valid_invalidDate_ReturnsFalse()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

// いい例：振る舞いを書いた版
// 不正な日付が指定された配達は不正だとみなされるべきである
public void Delivery_with_invalid_data_should_be_considered_invalid()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

// さらに改良
// 過去の日付が指定された配達は不正である
public void Delivery_with_a_past_date_is_invalid()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

```

- テストしたいのはメソッドではなくアプリの振る舞いなので、メソッド名を付けるのはおかしい。
- さらにテスト対象のメソッド名が変わるとテストのメンテナンスも必要になる。
- ただし、例外としてユーティリティ系のテストコードはこの規則から外すべき。

**テストクラスの命名**

- {クラス名}Tests が基本
- {クラス名}のクラスが呼び出しの起点になるだけで、このクラスだけのテストをしているわけではない（古典学派のテストの場合）。

## 第 4 章 良い単体テストを構成する 4 本の柱

**良い単体テストの 4 本の柱**

- 退行(regression)に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

**退行(regression)に対する保護**

- 退行 = バグ
  - 新しい機能を実装した結果、既存機能が意図しない挙動になるなど
- コードは大きくなるほど潜在的なバグは大きくなる
- どれだけバグを見つけられるかが大事

保護が備わっているか確認するには下記のことに注意すると良い

- テスト時に実行されるプロダクションコードの量
- そのコードの複雑さ
- そのコードが扱っているドメインの重要性

さらに、ライブラリを使用している場合は、そのライブラリもテスト時に実行するなどして退行を確認するなどの考慮も必要

開発の初期段階から大事になる要素であり、退行に対する保護が十分ではないと新規コード追加時に既存機能へのバグが持ち込まれやすくなる

**リファクタリングへの耐性**

ここでいうリファクタリングへの耐性とは、リファクタリングした結果としてプロダクションコードの振る舞いが正しいにも関わらず、テストが失敗する（偽陽性）ことへの耐性を指す。

偽陽性が多く発生すると開発者がコードの改善を止める、またはテストの失敗を軽視するようになり失敗につながる。

偽陽性を引き起こさないようにするために大事なこと

- 検証する対象を観察可能な振る舞いにする
- 内部的なコードの検証はしない

開発の初期段階にはリファクタリングをすることがないため、軽視されがち。しかし、コードが大きくなるにつれリファクタリングの必要性は大きくなっていく。そのためにもリファクタリングへの耐性をもつテストスイートの作成は重要

**迅速なフィードバック**

ここでいうフィードバックとはテストの速やかさのこと。テストを実行してから直ぐに結果が得られるとテストの実施頻度も増えて開発者がテスト実行に積極的になる。

**保守のしやすさ**

- テストケースを理解することがどの程度難しいか：プロダクトコードと同じかそれ以上の品質で理解しやすいものでないといけない
- テストを行うことがどの程度難しいか：プロセス外依存がどの程度あるか。DB の起動が必要かどうかなど

**理想的なテストの探求**

- テストコードもプロダクトコードも全てのコードは負債

  → あまり価値のないテストケースをいくつも用意するより、価値あるテストケースを必要なだけ用意するのが良い

- 退行に対する保護、リファクタリングへの耐性、迅速なフィードバックは互いに排反の関係にあり全てを完璧には満たせない。バランスが大事

- リファクタリングへの耐性はやるかやらないかしか選択肢がないため、退行に対する保護と迅速なフィードバックでバランスをとる

**ソフトウェアテストにおけるよく知られた概念**

- テストピラミッド

  テスト数の関係は基本的に単体テスト > 統合テスト > E2E テスト になる。ただし、シンプルなシステムなど例外はある。

- ホワイトボックステスト

  - アプリ内部でどのようなソースが動いているのかを理解して作成するテスト
  - 退行に対する保護は高い
  - リファクタリングへの耐性は低い

- ブラックボックステスト
  - アプリが何をするのかの仕様をもとに作成されるテスト
  - 退行に対する保護は低い
  - リファクタリングへの耐性は高い

基本的にはブラックボックステストを採用するべき。ただし、テストを分析する際にホワイトボックステストの考え方を利用し、コード網羅率などを計測することでテストスイートの品質を高めることができる。

## 第 5 章 モックの利用とテストの壊れやすさ

**モックとスタブの違い**

テスト・ダブルはモックとスタブに分けられる。

|      | モック                               | スタブ                               |
| ---- | ------------------------------------ | ------------------------------------ |
| 概要 | 外部に向かうコミュニケーションの模倣 | 内部に向かうコミュニケーションの模倣 |
| 例   | メール送信                           | DB からの値取得                      |

- メール送信を伴うテストをする際に、メール送信用の関数が呼び出されたか確認する際に使用するのはモック
- DB からの検索結果をテスト用に仕込んでおく際に作成するのがスタブ

- モックは外部に向かうコミュニケーションの模倣と検証を行う（必ず検証が必要というわけではない）
- スタブは設定するだけで、スタブが実行されたかは検証する意味はない

**観察可能な振る舞いと実装の詳細**

- 観察可能な振る舞い

  - 公開されている API
  - 端的にいえば public 関数
  - クライアントが目標を達成するために公開された操作

- 実装の詳細
  - 公開されていない API
  - 端的にいえば private 関数

観察可能な振る舞いの中で実装の詳細が呼び出されている必要がある。設計が不適切だと実装の詳細が漏洩が発生し、実装の詳細のテストが不十分になる恐れがある。このようなことを避けるためには、**カプセル化**をして実装の詳細を外部から隠す必要がある。

言い換えると、良い設計をすると単体テストのテストケースは自然と良いものが出来上がる。

**モックの利用とテストの壊れやすさの関係**

アプリを構成する二つの要素

- ドメイン層
  - アプリの中核を担うビジネスロジックを含む層
- アプリケーション・サービス層
  - ドメイン層と外部をつなげる役割
  - 全てのリクエストが最初に通る

アプリケーション・サービス層でリクエストを受け取り、必要なデータを DB から受け取りドメイン層のビジネスロジックで加工してアプリケーション・サービス層から返すイメージ

つまり、アプリケーション・サービス層はドメイン層を呼び出すがその逆はない。また、外部サービスとの通信が必要な場合はアプリケーション・サービス層から通信を行う。

観察可能な振る舞いとしてのテストはアプリケーション・サービス層を通してビジネスロジックをテストするようなものになる（？）。

複数のシステムが連動する場合を考える。別組織のシステムからアクセスされるシステムがあったとする。

- このシステムのシステム内の通信は実装の詳細になるため、モックを活用したテストをするのは不適切
- このシステムがメールサービスを利用するようなプロセス外依存がある場合、この部分をモックで検証するのは正しい
- しかし、プロセス外依存でもこのシステムからしかアクセスされない DB があった場合、そこをモック化するとリファクタリングへの耐性は下がるため不適切

**感想**

モックの使いどころがわかった気がする。
以前、プロジェクトで private な関数のテスト方法を必死こいて調べてたけどあれってダメなパターンしてたんだな。。。
どうしても細かいテストを書きたくなりがちになるときがあるけど、実装の詳細のテストになってないかしっかりと確認しながら書くようにしようと思う

## 第 6 章 単体テストの 3 つの手法

3 つの手法

- 出力値ベース・テスト（戻り値を確認するテスト）
  - テスト対象に入力値を渡して出力値を確認するテスト
  - 基本的に、協力者のオブジェクトの状態が変わらない
  - 例えば、T シャツ 4 枚かうと 1 枚無料的なロジックのテストはこの手法
- 状態ベース・テスト（状態を確認するテスト）
  - テスト対象の処理が完了した後に、テスト対象のクラスや協力者オブジェクトやプロセス外依存の状態を確認するテスト
  - 例えば、T シャツが購入されて在庫が減ったのを DB から確認とかのロジックを確認するテストはこの手法
- コミュニケーション・ベース・テスト（オブジェクト間のやり取りを確認するテスト）
  - モックを用いてテスト対象の協力者オブジェクト（外部依存）とのコミュニケーションを検証するテスト
  - 例えば、発送された際にメールが送られたかの確認はこの手法

**リファクタリングへの耐性の観点での比較**

状態ベース・テストでは協力者オブジェクトの状態も確認することもあり、偽陽性が起きやすくなる。つまり、実装の詳細に結びつきやすくなる。どの状態の確認がテストケースとしてふさわしいのか選択が必要。

**保守のしやすさでの比較**

状態ベース・テストでは複数の状態の検証が 1 つのテストケースで発生するため、保守が難しくなる傾向がある。そのため、同じような複数の状態の検証を行う場合はヘルパーメソッド等を作成して保守性をあげる手段などがある（リーダブルコードでも同様の記載があった！）

**関数型アーキテクチャ**

- 関数的殻（不変殻）
  - 決定を下すコード
  - 副作用は行いコード
  - 数学的関数を使い記述可能
- 可変殻
  - 決定に基づいてアクションを起こすコード
  - DB 操作などのコード

関数型アーキテクチャの流れ

1. 可変殻にて入力値が集められる
2. 関数的殻がその入力値をもとに決定を下す
3. 可変殻がその決定をもとの副作用（DB への書き込み等）を発生させる

if 文等を利用したロジックは関数的殻に入れ込み可変殻は if 文などのロジックを入れないようにすると、検証が必要な部分が明確になりテストケースが立てやすくなる？

**感想**

3 つの手法についての説明はよくわかり、コミュニケーション・ベース・テストが一番やっかいなのは理解できた。

最後の方（関数型アーキテクチャが出てきたあたり）はほんとに？と思うことが少しあった。関数型アーキテクチャを使用することで出力値ベースのテストが行いやすくなるような例（リスト 6.15）が上がっていたが、そこのテストは可変殻である Persister の検証はしていないが、ほんとによいのか？検証不要レベルのロジックではない気がする。

## 第 7 章 単体テストの価値を高めるリファクタリング

|                               | コードの複雑さ・ドメインに置ける重要性 | 協力者オブジェクトの数 | 特徴                                                                                   |
| ----------------------------- | -------------------------------------- | ---------------------- | -------------------------------------------------------------------------------------- |
| ドメイン・モデル/アルゴリズム | 大                                     | 少                     | 複雑なコードが含まれている。必ずしもドメインにおいて重要というわけではない             |
| 取るに足らないコード          | 小                                     | 少                     | 引数無しのコンストラクタや一行で書かれるプロパティなど。ドメインにおいても重要性はない |
| コントローラー                | 小                                     | 多                     | 複雑なことは行わないが、複数のコンポーネント（外部アプリを含む）との連携を行う         |
| 過度に複雑なコード            | 大                                     | 多                     | 複雑なコードであり、重要性が高く、多くの協力者オブジェクトを持つ                       |

- ドメイン・モデル/アルゴリズムの単体テストは保守コストが高くなることががなく、退行に対す対する保護を備えることができる
- 取るに足らないコードはテスト対象から避けるべき
- コントローラーのテストは統合テストで行うのが良い
- 過度に複雑なコードは単体テストの検証は必要だがテストが難しくなる場合が多い

過度に複雑なコードはできるだけドメイン・モデル/アルゴリズムかコントローラーに分割をすることで、結果的に良いテストケースが作成しやすくなる。

**質素なオブジェクト(Humble Object)を用いた過度に複雑なコードの分割**

質素なオブジェクト：例えば、MVC モデルでいうところの C(Controller)に該当する。

質素なオブジェクトを利用し過度に複雑なコード（ロジックと簡単にテストできない依存（DB アクセス等）が同時に存在するようなコード）を分割してテストしやすくする。

過度に複雑なコードからロジック（というか責任とか責務的なもの）を取り除いて複雑さを削減する。協力者オブジェクトが多いものに関しては特に複雑さを減らすとよい？

**感想**
この節は難しい。。。リファクタリングについて言及されているがそれによって単体テストの書き方がどのように変わるのかがいまいちよくわからない（と思っていたら次の節に書いてた）。ロジック部分を切り出して、過度に複雑なコードを単純化するのは良いと思うが、テスト・ケースの作成を誤るとリファクタリングへの耐性が低くなる気がした。

**プロダクション・コードの種類に基づく効果的な単体テスト**

単体テストの費用対効果において一番効率が良いのは、下記特徴を持つプロダクションコードになる。

- コードの複雑さ・ドメインに置ける重要性が高い
- 協力者オブジェクトが少ない

一方で、下記特徴を示すものは統合テストで扱う（もしくはモックを使った単体テスト？）

- コードの複雑さが低い
- 協力者オブジェクトが少ない

**コントローラーにおける条件付きロジックの扱い**

とにかくコントローラーは簡潔さが重要。しかし、何かしらの処理を実行するかを決定するロジックが必要になるなどのコントローラーが複雑になる対策として、確認後実行 (CanExecute/Execute)パターンの採用がある。

確認後実行 (CanExecute/Execute)パターン：データベースの読み込み処理などの重い処理を行う前に、その処理を行う必要があるのか確認する。

この確認後実行 (CanExecute/Execute)パターンをコントローラに入れるのではなく、うまくドメイン・モデル内に記述することでコントローラを簡潔にできる。

テストが必要なものは**クライアント**から観察可能な振る舞いだが、このクライアントとの意味は立場により変わる。

- エンドユーザーをクライアントとしてみる場合
- コントローラをクライアントとしてみる場合

おそらく単体テストは「コントローラをクライアントとしてみる場合」で行うのだと思う。多分ね。

**感想**
最後の方のコントローラからロジックを抜き出す部分の説明が特に難しかった。とにかくコントローラは単純なものにする必要があるくらいの理解度で終わった。。ただ、このようにすることでドメイン部分の単体テスト（つまりは、観察可能な振る舞い）が行いやすくなるのは理解ができた。

## 第 8 章 なぜ、統合(integration)テストを行うのか

単体テストの性質である下記 3 つのうちどれかを損なえばそれは統合テストになる

- 1 単位の振る舞いを検証すること
- 実行時間が短いこと
- 他のテストケースから隔離された状態で実行されること

モックを使用しないプロセス外依存と結びついたコードをテストする場合は統合テストになる。

統合テストと単体テストの比較

|                          | 統合テスト | 単体テスト |                                                                         |
| ------------------------ | ---------- | ---------- | ----------------------------------------------------------------------- |
| 退行に対する保護         | 高い       | 低い       | 多くのコードを検証するため                                              |
| リファクタリングへの耐性 | 高い       | 低い       | テストケースがプロダクションコードとあまり紐づかないため                |
| 保守コスト               | 高い       | 低い       | プロセス外依存があり、1 つのテストケースのコード量も増えるため          |
| テスト件数               | 少ない     | 多い       | 統合テストでは 1 件の正常系と、単テではできない異常系テストの実施が良い |

**2 種類のプロセス外依存**

- 管理下にある依存
  - DB などそのアプリからしかアクセスされないようなもの
- 管理下にない依存
  - メールサービスなど他のアプリからも使用されるもの

管理下にない依存に関してはモックを利用して統合テストを行う。一方で、管理下にあるものに関してはモックを利用しないテストを行うことで仕様が壊れていないか確認することができる

- インターフェイスの定義が必要な場合
  - 実装クラスが複数ある場合
  - 管理下にないプロセス外依存のモックのため

**ログ出力に対するテスト**

ログの内容が観察可能な振る舞いか実装の詳細で判断する

- 観察可能な振る舞い：ユーザーやアプリのクライアント、非開発者が見る想定のログ
- 実装の詳細：開発者が見るログ

テストする際は、logger 用のインターフェイスを作成してモックを用いたテストをするなどの方法がある。

## 第 9 章 モックのベストプラクティス

- 大前提としてモックを利用するのは管理下にない依存であること
- モックの利用は統合テストから（単体テストでは使用しない）
- モックを作成した場合は、呼び出されたかや呼び出し回数が想定通りか確認する

## 第 10 章 データベースに対するテスト

**ソースコード管理システムを用いたスキーマ管理**

ソースコード管理システム（Git 等）にスキーマに関する変更を格納しておく。
さらに、そのスキーマに参照データ（初期データのようなもの）も含めておく。

**データベースに対する変更の本番環境への反映：状態ベース vs. 移行ベース**

- 状態ベース
  - 開発環境に対して、行った変更をそのまま本番に反映する
  - 手順はツール任せ
- 移行ベース
  - 開発作業で新しくなった機能を本番環境に移行する
  - 手順は開発者が作成

開発中は状態ベースでの移行が良いが、本番稼働すると中身のデータ整備を行う必要が出る場合がある。その他場合は移行ベースを用いる

**データベース・トランザクションの管理**

- トランザクションが成功したかどうかで DB を更新するようなコードにする
- トランザクションを単位作業(Unit of Work)として 1 つにまとめる

**感想**

この書籍では DB のテストは単体テストではなく統合テストで行うべきという主張だと思うが、SQL のバグの発見が統合テストになるのはどうかと思う。テーブルの結合条件などもある意味ビジネスロジック的な要素を含むのでは？と思ってしまう。個人的には DB（というか SQL）の検証は単体テストでするようなテスト・ケースにした方がいいと思う。

## 第 11 章 単体テストのアンチパターン

**プライベートなメソッドに対する単体テスト**

プライベートなメソッドは実装の詳細に該当する部分なため、単体テストで直接的にテストをするべきではない。そのプライベートなメソッドを呼び出しているパブリックなメソッドを通してテストされるべきである。もし、パブリックなメソッドからの呼び出しで検証しきれない場合は、デットコードがないかの確認などを行う必要がある。

**テストへのドメイン知識の漏洩**

テストコード内にロジックを書いて期待値を導き出して、それを実際に出力された値と検証するのはアンチパターン。
期待値自体をテストのインプットとして与えるべき。

**感想**
プライベートなメソッドに対する単体テストは以前したことがある。。。確かによくないなと感じた。。。

## 全体的な感想とか覚えていた方が良さそうなこと

- 網羅率はテストスイートの悪さの指標であり良さの指標にはならない
- 単体テストのフェーズは準備、実行、確認であり実行は一行で記述する
- 良い単体テストの 4 本の柱
  - 退行(regression)に対する保護
  - リファクタリングへの耐性
  - 迅速なフィードバック
  - 保守のしやすさ
- 単体テストは観察可能な振る舞いに足して実施し、実装の詳細に対しては行わない
- 過度に複雑なコード（ロジックの重要度が高く、協力者オブジェクトが多い）ものはリファクタリングを行いロジック部分と協力者オブジェクトとのコミュニケーション部分を分離する