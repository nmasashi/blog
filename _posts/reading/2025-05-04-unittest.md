---
layout: post
title: "単体テストの考え方/使い方"
date: 2025-06-04
categories: reading unittesting
---

![]({{site.baseurl}}/images/reading/unit_testing/bookcover.jpg)

これ読んだまとめとか感想とか

## 第 1 章 なぜ、単体テストを行うのか

- 単体テストをすることでソフトウェア開発プロジェクトを持続可能にするため

  → 持続可能とはソースの変更が会った際に、退行した機能がないか検出できているかが大きい

テストの品質が悪い場合はテストなしと同じようにプロジェクトは停滞する可能性がある。
単体テストがどのように、このプロジェクトを助けるのかの理解をしていないと品質が低いテストになるリスクが大きくなる。

テストスイート：目的や対象ごとにテスト・ケースを集めたもの

テストの網羅率(coverage)はテスト・スイートの質の良さを示すことができるものではない（悪さを示すことはできる）。

コード網羅率ではテストで実行された行数の割合が算出される。しかし、三項演算子などで一行で二つの条件分岐があるようなコードは想定している網羅率にならないことがある。
この場合は、分岐網羅率を図ることで対応することはできる。

**網羅率が高くてもテストスイートの質がいいとは言えない理由**

- ただその行を通っただけで何かを確かめた（テスト）したとは限らない
- ライブラリを使用した場合、ライブラリ内のコードは網羅率の計算には入らない

網羅率は目標にするのではなく、テストが十分に実施されていない指標にするべき

**テストスイートの品質をあげるには、結局のところテストケースをひとつづつ評価していくしかない。**

テストの実施は開発サイクルの中に含まれる必要がある

システムの重要なビジネスロジックに対するテストに時間を費やすべき。それ以外の部分は簡易なものか間接的なものでも OK

**単体テストで最小限の保守コストで最大限の効果を生み出すには**

- 価値あるテストケースを認識できること
- 価値あるテストケースを作成できること

**感想**

網羅率を目標にする意味があまりないことの意味がわかった。
ただ、「網羅率 100%いってないじゃん！！それだめじゃね？」と言われたらなんて言い返せばいいのかまだよくわからない。目標として 100%を目指すのは間違えだけどよいテストスイートができてると、おのずと 100%になる？

## 第 2 章 単体テストとは何か？

**単体テストの性質**

- 自動化されている
- 「単体 (unit)」と呼ばれる少量のコードを検証する
- 実行時間が短い
- 隔離された状態で実行される

**ロンドン学派（モック主義者）**

- テスト対象に依存するクラスはテスト・ダブルに置き換える
- 一度に 1 つのクラスしか検査しない
- テスト失敗時に原因クラスがすぐわかる
- クラス間の依存が多く複雑な場合に有効
- テストに必要な準備を減らせる
- テストケースがシンプルになる

**古典学派（デトロイト派）**

- DB などのシステム外の依存（ = 共有依存）はテスト・ダブルに置き換える
- 共有依存以外はテスト・ダブルは使用しない
- 複数のテストを同時・順番を入れかえてもよい
- 確認できる範囲が広い

テスト・ダブル：モックと同じような意味で使用されているが厳密には違う。モックはテスト・ダブルの一種

依存の種類

- 依存
  - 共有依存：DB とかファイルとか
  - プライベート依存
    - 可変依存：他クラスなど
    - 不変依存：値オブジェクト（定数など）

ロンドン学派と古典学派の特徴

|                            | ロンドン学派       | 古典学派       |
| -------------------------- | ------------------ | -------------- |
| 隔離対象                   | 単体               | テスト・ケース |
| 単体の意味                 | 1 つのクラス       | 1 つの機能     |
| テスト・ダブル置き換え対象 | 共有依存、可変依存 | 共有依存       |

**細かな粒度による検証**

- ロンドン学派：テスト単位では細かすぎて、なんの検証か不明になることがある。特に非開発者には何のテストか不明になりがち
- 古典学派：テスト対象のが広いため、どのようなストーリーなのかがわかりやすい

**複雑な依存関係を持つ者に対する単体テスト**

- ロンドン学派：テスト対象外をモックにするため、依存関係が複雑なシステムの単体テストも容易に書くことができる
- 古典学派：テストのために関係するクラスの準備が必要なため、依存関係が複雑だと準備が大変

ただ、古典学派の主張は複雑な依存関係を持つシステムの場合、設計に問題がある場合がある可能性がある。

**テストが失敗したとき**

- ロンドン学派：テストが失敗した場合、テスト対象以外がモック化されているため、修正が必要な箇所が直ぐにわかる
- 古典学派：共有依存以外モック化していないためどこが修正が必要なのか直ぐにはわからない

ただ、古典学派の問題点はそもそも問題なのか？単体テストの理想はコードが変更される度に実施されるべきで、そうしていれば最後に変更したコードに原因があるのは直ぐにわかる。
また、複数のテストーケースが NG になる場合があるが、それは影響範囲の大きさを知ることができる有益な情報になる。

**古典学派の考え方を踏まえた単体テストの考えかた**

- 1 単位の振る舞いを検証すること
- 実行時間が短いこと
- 他のテストケースから隔離された状態で実行されること

**感想**

振る舞いの定義が重要だと感じた。t_wada 曰く、「この本では対象の実行前後の差異とそれによって目的が達成されたかという意味では？」とのこと

## 第 3 章 単体テストの構造的解析

**単体テストのフェーズ（AAA パターン）**

- 準備(Arrange)：テストケースの事前条件を満たし、依存状態を設定する。
- 実行(Act)：テスト対象のメソッドの呼び出し。
- 確認(Assert)：実行結果が想定通りが確認する。実行の際の戻り値や依存関係にあるオブジェクトの状態変化が想定通りかなどの確認を行う。

例

```java
public class CalculatorTests
{
  [Fact]
  public void Sum_of_two_numbers()
  {
    // 準備 (Arrange)
    double first = 10;
    double second = 20;
    var calculator = new Calculator();

    // 実行 (Act)
    double result = calculator.Sum(first, second);

    // 確認 (Assert)
    Assert.Equal(30, result);
  }
}

```

**アンチパターン**

- 準備 → 実行 A→ 確認 A→ 実行 B→ 確認 B のように複数の実行と確認を行うこと

  → 分割した単体テストとするべき

- if 文の使用

  → テストないにロジックが入ると理解しずらい

**各フェーズのコード量**

- 準備フェーズのコードが一番大きくなる
  - 他テストケースでも共通的に使用する準備フェーズのコードがあるならプライベート関数などで共有するとよい
- 実行フェーズのコードは 1 行が基本
  - カプセル化などの設計が正しくできているのかなどの観点で設計を見直す
- 確認フェーズが大きくなりすぎることには注意を払っておく

**各テストケースはプロダクションコードが解決しようとしている物語について語るべき**

もしテストが失敗した場合は、コード修正か物語（設計？）の修正を行う必要がある

単体テストの理想形は非開発者でも内容が伝わること。

**テスト・フィクスチャの作成**

テスト・フィクスチャ：テストを実施する際に使用するオブジェクト。データベースのデータやディス上のファイル等。テストケースが実行される前に決められた状態に毎回しておくために準備するもの

アンチパターン

- コンストラクタで固定値のようなものを設定する。
  - 固定値の変更が複数テストに影響を与える
  - テストが読みにくくなる
  - 例外として、すべてのテストパターンで同じテスト・フィクスチャを利用する場合はコンストラクタでも OK

いい方法

- 固定値ではなくプライベートの関数を作成して、テスト用のオブジェクトを返すようなものを作成する

**テストメソッドの命名**

- 厳格な命名規則のせいで何をしたいテストかわからなくなる場合があるので、ある程度の自由さが必要
- 非開発者に伝わるように心掛ける
- アンダースコアで区切るのは基本

テストしたいメソッドではなくストーリをテストメソッドにする方法もあり

```java
// 例：配送サービスで過去日付が指定できないことをテストしたいテストメソッド

// よくない例：関数名をテストメソッドに入れた版
// IsDeliveryValid_不正な日付はFalseを返す
public void IsDelivery_Valid_invalidDate_ReturnsFalse()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

// いい例：振る舞いを書いた版
// 不正な日付が指定された配達は不正だとみなされるべきである
public void Delivery_with_invalid_data_should_be_considered_invalid()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

// さらに改良
// 過去の日付が指定された配達は不正である
public void Delivery_with_a_past_date_is_invalid()
{
  ...
  bool = isValid = sut.IsDeliveryVValid(delivery);
  ...
}

```

- テストしたいのはメソッドではなくアプリの振る舞いなので、メソッド名を付けるのはおかしい。
- さらにテスト対象のメソッド名が変わるとテストのメンテナンスも必要になる。
- ただし、例外としてユーティリティ系のテストコードはこの規則から外すべき。

**テストクラスの命名**

- {クラス名}Tests が基本
- {クラス名}のクラスが呼び出しの起点になるだけで、このクラスだけのテストをしているわけではない（古典学派のテストの場合）。

## 第 4 章 良い単体テストを構成する 4 本の柱

**良い単体テストの 4 本の柱**

- 退行(regression)に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

**退行(regression)に対する保護**

- 退行 = バグ
  - 新しい機能を実装した結果、既存機能が意図しない挙動になるなど
- コードは大きくなるほど潜在的なバグは大きくなる
- どれだけバグを見つけられるかが大事

保護が備わっているか確認するには下記のことに注意すると良い

- テスト時に実行されるプロダクションコードの量
- そのコードの複雑さ
- そのコードが扱っているドメインの重要性

さらに、ライブラリを使用している場合は、そのライブラリもテスト時に実行するなどして退行を確認するなどの考慮も必要

開発の初期段階から大事になる要素であり、退行に対する保護が十分ではないと新規コード追加時に既存機能へのバグが持ち込まれやすくなる

**リファクタリングへの耐性**

ここでいうリファクタリングへの耐性とは、リファクタリングした結果としてプロダクションコードの振る舞いが正しいにも関わらず、テストが失敗する（偽陽性）ことへの耐性を指す。

偽陽性が多く発生すると開発者がコードの改善を止める、またはテストの失敗を軽視するようになり失敗につながる。

偽陽性を引き起こさないようにするために大事なこと

- 検証する対象を観察可能な振る舞いにする
- 内部的なコードの検証はしない

開発の初期段階にはリファクタリングをすることがないため、軽視されがち。しかし、コードが大きくなるにつれリファクタリングの必要性は大きくなっていく。そのためにもリファクタリングへの耐性をもつテストスイートの作成は重要

**迅速なフィードバック**

ここでいうフィードバックとはテストの速やかさのこと。テストを実行してから直ぐに結果が得られるとテストの実施頻度も増えて開発者がテスト実行に積極的になる。

**保守のしやすさ**

- テストケースを理解することがどの程度難しいか：プロダクトコードと同じかそれ以上の品質で理解しやすいものでないといけない
- テストを行うことがどの程度難しいか：プロセス外依存がどの程度あるか。DB の起動が必要かどうかなど

**理想的なテストの探求**

- テストコードもプロダクトコードも全てのコードは負債

  → あまり価値のないテストケースをいくつも用意するより、価値あるテストケースを必要なだけ用意するのが良い

- 退行に対する保護、リファクタリングへの耐性、迅速なフィードバックは互いに排反の関係にあり全てを完璧には満たせない。バランスが大事

- リファクタリングへの耐性はやるかやらないかしか選択肢がないため、退行に対する保護と迅速なフィードバックでバランスをとる

**ソフトウェアテストにおけるよく知られた概念**

- テストピラミッド

  テスト数の関係は基本的に単体テスト > 統合テスト > E2E テスト になる。ただし、シンプルなシステムなど例外はある。

- ホワイトボックステスト

  - アプリ内部でどのようなソースが動いているのかを理解して作成するテスト
  - 退行に対する保護は高い
  - リファクタリングへの耐性は低い

- ブラックボックステスト
  - アプリが何をするのかの仕様をもとに作成されるテスト
  - 退行に対する保護は低い
  - リファクタリングへの耐性は高い

基本的にはブラックボックステストを採用するべき。ただし、テストを分析する際にホワイトボックステストの考え方を利用し、コード網羅率などを計測することでテストスイートの品質を高めることができる。

## 第 5 章 モックの利用とテストの壊れやすさ

**モックとスタブの違い**

テスト・ダブルはモックとスタブに分けられる。

|      | モック                               | スタブ                               |
| ---- | ------------------------------------ | ------------------------------------ |
| 概要 | 外部に向かうコミュニケーションの模倣 | 内部に向かうコミュニケーションの模倣 |
| 例   | メール送信                           | DB からの値取得                      |

- メール送信を伴うテストをする際に、メール送信用の関数が呼び出されたか確認する際に使用するのはモック
- DB からの検索結果をテスト用に仕込んでおく際に作成するのがスタブ

- モックは外部に向かうコミュニケーションの模倣と検証を行う（必ず検証が必要というわけではない）
- スタブは設定するだけで、スタブが実行されたかは検証する意味はない

**観察可能な振る舞いと実装の詳細**

- 観察可能な振る舞い

  - 公開されている API
  - 端的にいえば public 関数
  - クライアントが目標を達成するために公開された操作

- 実装の詳細
  - 公開されていない API
  - 端的にいえば private 関数

観察可能な振る舞いの中で実装の詳細が呼び出されている必要がある。設計が不適切だと実装の詳細が漏洩が発生し、実装の詳細のテストが不十分になる恐れがある。このようなことを避けるためには、**カプセル化**をして実装の詳細を外部から隠す必要がある。

言い換えると、良い設計をすると単体テストのテストケースは自然と良いものが出来上がる。

**モックの利用とテストの壊れやすさの関係**

アプリを構成する二つの要素

- ドメイン層
  - アプリの中核を担うビジネスロジックを含む層
- アプリケーション・サービス層
  - ドメイン層と外部をつなげる役割
  - 全てのリクエストが最初に通る

アプリケーション・サービス層でリクエストを受け取り、必要なデータを DB から受け取りドメイン層のビジネスロジックで加工してアプリケーション・サービス層から返すイメージ

つまり、アプリケーション・サービス層はドメイン層を呼び出すがその逆はない。また、外部サービスとの通信が必要な場合はアプリケーション・サービス層から通信を行う。

観察可能な振る舞いとしてのテストはアプリケーション・サービス層を通してビジネスロジックをテストするようなものになる（？）。

複数のシステムが連動する場合を考える。別組織のシステムからアクセスされるシステムがあったとする。

- このシステムのシステム内の通信は実装の詳細になるため、モックを活用したテストをするのは不適切
- このシステムがメールサービスを利用するようなプロセス外依存がある場合、この部分をモックで検証するのは正しい
- しかし、プロセス外依存でもこのシステムからしかアクセスされない DB があった場合、そこをモック化するとリファクタリングへの耐性は下がるため不適切

**感想**

モックの使いどころがわかった気がする。
以前、プロジェクトで private な関数のテスト方法を必死こいて調べてたけどあれってダメなパターンしてたんだな。。。
どうしても細かいテストを書きたくなりがちになるときがあるけど、実装の詳細のテストになってないかしっかりと確認しながら書くようにしようと思う

## 第 6 章 単体テストの 3 つの手法

3 つの手法

- 出力値ベース・テスト（戻り値を確認するテスト）
  - テスト対象に入力値を渡して出力値を確認するテスト
  - 基本的に、協力者のオブジェクトの状態が変わらない
  - 例えば、T シャツ 4 枚かうと 1 枚無料的なロジックのテストはこの手法
- 状態ベース・テスト（状態を確認するテスト）
  - テスト対象の処理が完了した後に、テスト対象のクラスや協力者オブジェクトやプロセス外依存の状態を確認するテスト
  - 例えば、T シャツが購入されて在庫が減ったのを DB から確認とかのロジックを確認するテストはこの手法
- コミュニケーション・ベース・テスト（オブジェクト間のやり取りを確認するテスト）
  - モックを用いてテスト対象の協力者オブジェクト（外部依存）とのコミュニケーションを検証するテスト
  - 例えば、発送された際にメールが送られたかの確認はこの手法

**リファクタリングへの耐性の観点での比較**

状態ベース・テストでは協力者オブジェクトの状態も確認することもあり、偽陽性が起きやすくなる。つまり、実装の詳細に結びつきやすくなる。どの状態の確認がテストケースとしてふさわしいのか選択が必要。

**保守のしやすさでの比較**

状態ベース・テストでは複数の状態の検証が 1 つのテストケースで発生するため、保守が難しくなる傾向がある。そのため、同じような複数の状態の検証を行う場合はヘルパーメソッド等を作成して保守性をあげる手段などがある（リーダブルコードでも同様の記載があった！）

**関数型アーキテクチャ**

- 関数的殻（不変殻）
  - 決定を下すコード
  - 副作用は行いコード
  - 数学的関数を使い記述可能
- 可変殻
  - 決定に基づいてアクションを起こすコード
  - DB 操作などのコード

関数型アーキテクチャの流れ

1. 可変殻にて入力値が集められる
2. 関数的殻がその入力値をもとに決定を下す
3. 可変殻がその決定をもとの副作用（DB への書き込み等）を発生させる

if 文等を利用したロジックは関数的殻に入れ込み可変殻は if 文などのロジックを入れないようにすると、検証が必要な部分が明確になりテストケースが立てやすくなる？
